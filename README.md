# project_abiturietn
Данная программа написана в рамках проекта "Абитуриент". Проект посвящен исследованию эффективности профориентационных мероприятий

Основные модули:
CreatedBaseClass_V3.py - В файле описывается класс create_base создающий таблиы базы данных в соответствии с установленной структурой. ВАЖНО!!! предполагается, что сама база данных уже создана 
						средствами администрирования БД. В текущий момент БД либо пустая, либо содержит таблицы согласно установленной структуре. При запуске скрипта все текущие таблицы будут удалены
						если они были созданы и буду созданы таблицы с нуля. Таким образом можно полностью создать или пересоздать базу данных. 
						
prepair_data.py - вносит записи в таблицы базы даннхы. В модуле описан класс prepar_data. На входе документ формата excel = результат опроса в яндекс (см. пример файла 'DOD_V_2022+Ипостаси.xlsx'). Документ должен содержать обязательные поля:
					'Фамилия:', 'Имя:', 'Отчество:', 'Номер телефона:', 'E-mail:', 'Страна:', 'Регион:', 'Город:','Учебное заведение:', 'Класс:', 'Время создания'. 
					Остальные столбцы представляют собой ответы на вопросы.  Для того, что бы программа понимала, какие именно столбцы обрабатываем, на вход подается файл, содержащий список
					полей являющихся вопросами для обработки (см. пример файла 'list_questions.csv').
					Результатом работы программы является внесение записей в базу данных. 


рассмотрим подробнее работу модулей:
					
					
	CreatedBaseClass_V3 - основной объект create_base. Рассмотрим методы:
		def __init__(self, id_users): - инициализация класса и подключение к базе данных (конструктор класса)
		def __del__(self): - закрытия соединение с базой данных (деструктор класса)
		def del_all(self): - удаление всех таблиц, если существуют
		def cr_city(self) - создаем таблицу городов
		def cr_school(self):  - создаем таблицу школ
		def cr_event(self): - создаем таблиу мероприятий (евентов)
		def cr_anket(self):  - создаем таблицу анкет
		def cr_question(self): - создаем таблицу вопросов
		def cr_possible_answer(self):  - создаем таблицу вариантов ответов.
		def cr_subject(self):  - создаем таблицу субъектов
		def cr_event_record(self):  - создаем таблицу event_record
		def cr_answer(self):  - создаем таблицу ответов. 
		!!! некоторые поля могут отличаться от полей в установленной структуре. Например для поля email в таблице субъектов 16 символов оказаолось мало и даже 32. Это поле установлено в 64 символа
		поле creation_time - установлено без часового пояся, т.к. данные собираются без часового пояся. Могут быть и другие мелкие отличия
		
		Основной сценарий работы: 
		db=create_base() - создаем объект и полключаемся
		db.del_all() - удаляем все таблицы, если они есть
		#создаем чистые таблицы
		db.cr_city()
		db.cr_school()
		db.cr_subject()
		db.cr_event()
		db.cr_anket()
		db.cr_question()
		db.cr_possible_answer()
		db.cr_event_record()
		db.cr_answer()

		#коммитим и закрываем соединение
		db.conn.close()
	
	
	prepair_data.py - основной объект prepar_data. Рассмотрим методы
		def __init__(self, df, list_questions, event,anket, regular_columns=
                    ['Фамилия:', 'Имя:', 'Отчество:', 'Номер телефона:',
                    'E-mail:', 'Страна:', 'Регион:', 'Город:',
                    'Учебное заведение:', 'Класс:', 'Время создания'
                    ]) -> None: - инициализация класса. Основные входы: файл с результатами опросов (аналогичный 'DOD_V_2022+Ипостаси.xlsx'), 
								  файл с перечнем полей, являющихся вопросами (аналогичный 'list_questions.csv'), 
								  event - словарь содержащий сведения о мероприятии по форме: event={'event':'название', 'date':'дата'},
								  anket - словарь содержащий сведения об опросе (анкете) по форме: anket={'type_anket':'тип анкеты', 'name_anket':'имя анкеты'}
		def connect_base(self) -> bool - соединение с БД
		def disconnect(self) -> bool - закрытие соединения
		def execute_values(self, conn, df, table) - ДОЗАПИСЬ данные в таблицу. conn - соединение с БД, df - таблица по форме pandas DataFrame, которую необходимо записать (важно, что бы поля важно,
													что бы поля в df совпадали с полями таблицы table в БД, кроме поля PK id, которое создается и заполняется автоматически), 
													table - имя таблицы в которую необходимо произвести дозапись
		
		def query_get_city(self): - запрашиваем из базы все города, которые записаны в настоящий момент
		def query_set(self, df, table_name) -> bool: - интерфейс для execute_values включающий в себя открытие соединения, вызов записи, коммит, закрытие соединения
		def query_get_school(self): - запрос таблицы школ. (важно, школа мерджится со страной, регионом, городом и в таком формате возвращается)
		def query_get_subject(self): - запрашиваем из базы субъектов учитывая, что субъект опредялются вместе со школой и городом и в этом формате возвращается
		def query_get_id_event(self): - находим event_id в базе данных для текущего евента. Предполагается, что текущий евент к этому моменту уже записан в базу данных. Если подходящих event_id 
										не нашлось выдаем ошибку и прерываем выполнение программы. Если подходящих event_id больше одного - выдаем ошибку и прерываем программу
		def query_get_id_anket(self): - аналогично query_get_id_event, но для 'anket_id'
		def query_get_question(self): - запрашиваем из базы все вопросы
		def query_get_possible_anser(self): - запрашиваем из базы все возможные ответы
		def query_get_event_record(self) - запрашиваем из базы таблицу event_record
		def predict(self): - основная функция обеспечивающая реализацую основного сценария. Предполагается, что к этому моменту объект класса корректно инициирован, создана база данных и
							соответствующие таблицы. В функции производится последовательный вызов функций по преобразованию данных и записи таблиц
		def check_data(self): - проверяем наличие обязательных столбцов во входящем файле ( аналогичный 'DOD_V_2022+Ипостаси.xlsx')
		def get_stru_questions(self): - на основе входящего файла ( аналогичный 'list_questions.csv') формируем перечень уникальных вопросов. Вопросы парсятся следующим образом:
										1. если в вопрос не содержит символа ' / ', то он относится к открытым одностолбцовым вопросами
										2. если вопрос содержит символ ' / ', то часть до этого символа отностися к вопросу, часть после этого символа относится к ответу. Вопрос считается закрытм типом
										3. если в вопросе содержистя несколько симоволов ' / ', то учитывается только последний символ. Обработка аналогична случаю 2. 
		def parsing_question(self): - переходим от многостолбцового представления ответов, к одностолбцовому
									вариант когда на вопрос имеется много ответов и каждый ответ в отдельном столбце
									формируем таблицу, когда один вопрос со всеми ответами представляются в одном столбце
		
		def get_tab_city(self) -> bool: на основании файла ( аналогичный 'DOD_V_2022+Ипостаси.xlsx') Формируем перечень уникальных городов, 
										находим те из них, которые отсутствуют в базе данных и Дополняем таблицу городов новыми городами
		def get_tab_school(self) -> bool: аналогично get_tab_city, только со школами, но с учетом того, что школа мерджится со страной, регионом и городом
		def get_tab_subject(self) -> bool: - аналогично get_tab_city, только с субъектами, но с учетом того, что субъект мерджится по фамилии, имени, отчетству, стране, региону, городу, школе
		def get_tab_event_record(self) -> bool: - заполняем таблицу event_record.
		def get_tab_question(self) -> bool:  - заполняем таблицу вопросов. Находим все уникальные вопросы в файле и записываем их в таблицу с привязкой к анкете
		def get_tab_possible_answer(self) -> bool: - заполняем таблицу возможных ответов. Парсим все ответы для закрытых вопросов и указываем отсутствие ответа для открытых вопросов. Записываем
													возможные ответы в таблицу с привязкой к вопросами
		def get_tab_answer(self) -> bool: - и наконец-то заполняем таблицу  ответов. Берем все ответы, мерджим по вопросам, для привязки к вопросам, мерджим по субъектам, событию и анкете для 
											привязки к event_record, мерджим по возможным ответам для привязки к возможным ответам. Записываем в таблицу. 
		Основной сценарий работы:
		df=pd.read_excel('DOD_V_2022+Ипостаси.xlsx') - Загрузка файла данных
		list_questions=pd.read_csv('list_questions.csv', sep='  ') - загрузка вариантов ответов
		event={'event':'ДОД2022-весна', 'date':'2022.04.10'} - указываем сведения о событии
		anket={'type_anket':'тип анкеты', 'name_anket':'имя анкеты'} - указываем сведения об анкете
		
		prepair=prepar_data(df=df, list_questions=list_questions, event=event,anket=anket ) - инициируем объект класса
		if prepair.predict()==False: 														- запускаем на исполнение с контролем
			print('Format of data is not valid')
		print('Format of data is valid')
			